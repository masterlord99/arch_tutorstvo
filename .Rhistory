theme_minimal() +
labs(title = "Stochastic Process of Simulations",
subtitle = subtitle_text,
x = "Month",
y = "Value") +
theme(legend.position = "none")
placa_couple = 5000
procent_invest = 0.4
roi_market = 0.09
sd = 0.04
leta = 30
N = 1000
razvoji= list()
for(i in 1:N){
cash = placa_couple*procent_invest
## razvoj
for(j in 2:(leta*12)){
cash[length(cash)] = cash[length(cash)]*(1 + rnorm(1,mean=roi_market/13,sd=sd)) ## market roi
cash = c(cash,cash[length(cash)]+placa_couple*procent_invest)
}
razvoji[[length(razvoji)+1]] = cash
}
razvoji = do.call(cbind,razvoji)
library(ggplot2)
library(reshape2)
library(scales)  # For normal notation on y-axis
df <- as.data.frame(razvoji)
df$Month <- 1:nrow(df)
# Reshape data to long format
df_long <- melt(df, id.vars = "Month", variable.name = "Scenario", value.name = "Value")
# Compute the mean expectation for each month
df_mean <- aggregate(Value ~ Month, data = df_long, FUN = mean)
# Subtitle text
subtitle_text <- paste(
"Params: Placa Couple =", placa_couple,
"| % Invest =", procent_invest,
"| ROI Market =", roi_market,
"| SD =", sd,
"| Years =", leta,
"| N =", N
)
# Plot with individual scenarios and mean line
ggplot(df_long, aes(x = Month, y = Value, group = Scenario)) +
geom_line(alpha = 0.1, color = "blue", linewidth = 0.5) +  # Individual scenarios
geom_line(data = df_mean, aes(x = Month, y = Value), color = "red",
linewidth = 1.2, inherit.aes = FALSE) +  # Mean expectation
scale_y_continuous(labels = label_number(scale_cut = cut_short_scale())) +  # Normal notation
theme_minimal() +
labs(title = "Stochastic Process of Simulations",
subtitle = subtitle_text,
x = "Month",
y = "Value") +
theme(legend.position = "none")
placa_couple = 5000
procent_invest = 0.4
roi_market = 0.09
sd = 0.04
leta = 3
N = 1000
razvoji= list()
for(i in 1:N){
cash = placa_couple*procent_invest
## razvoj
for(j in 2:(leta*12)){
cash[length(cash)] = cash[length(cash)]*(1 + rnorm(1,mean=roi_market/13,sd=sd)) ## market roi
cash = c(cash,cash[length(cash)]+placa_couple*procent_invest)
}
razvoji[[length(razvoji)+1]] = cash
}
razvoji = do.call(cbind,razvoji)
library(ggplot2)
library(reshape2)
library(scales)  # For normal notation on y-axis
df <- as.data.frame(razvoji)
df$Month <- 1:nrow(df)
# Reshape data to long format
df_long <- melt(df, id.vars = "Month", variable.name = "Scenario", value.name = "Value")
# Compute the mean expectation for each month
df_mean <- aggregate(Value ~ Month, data = df_long, FUN = mean)
# Subtitle text
subtitle_text <- paste(
"Params: Placa Couple =", placa_couple,
"| % Invest =", procent_invest,
"| ROI Market =", roi_market,
"| SD =", sd,
"| Years =", leta,
"| N =", N
)
# Plot with individual scenarios and mean line
ggplot(df_long, aes(x = Month, y = Value, group = Scenario)) +
geom_line(alpha = 0.1, color = "blue", linewidth = 0.5) +  # Individual scenarios
geom_line(data = df_mean, aes(x = Month, y = Value), color = "red",
linewidth = 1.2, inherit.aes = FALSE) +  # Mean expectation
scale_y_continuous(labels = label_number(scale_cut = cut_short_scale())) +  # Normal notation
theme_minimal() +
labs(title = "Stochastic Process of Simulations",
subtitle = subtitle_text,
x = "Month",
y = "Value") +
theme(legend.position = "none")
source("~/sim.R")
source("~/sim.R")
placa_couple = 5000
procent_invest = 0.4
roi_market = 0.09
sd = 0.04
leta = 10
N = 1000
razvoji= list()
for(i in 1:N){
cash = placa_couple*procent_invest
## razvoj
for(j in 2:(leta*12)){
cash[length(cash)] = cash[length(cash)]*(1 + rnorm(1,mean=roi_market/13,sd=sd)) ## market roi
cash = c(cash,cash[length(cash)]+placa_couple*procent_invest)
}
razvoji[[length(razvoji)+1]] = cash
}
razvoji = do.call(cbind,razvoji)
library(ggplot2)
library(reshape2)
library(scales)  # For normal notation on y-axis
df <- as.data.frame(razvoji)
df$Month <- 1:nrow(df)
# Reshape data to long format
df_long <- melt(df, id.vars = "Month", variable.name = "Scenario", value.name = "Value")
# Compute the mean expectation for each month
df_mean <- aggregate(Value ~ Month, data = df_long, FUN = mean)
# Subtitle text
subtitle_text <- paste(
"Params: Placa Couple =", placa_couple,
"| % Invest =", procent_invest,
"| ROI Market =", roi_market,
"| SD =", sd,
"| Years =", leta,
"| N =", N
)
# Plot with individual scenarios and mean line
ggplot(df_long, aes(x = Month, y = Value, group = Scenario)) +
geom_line(alpha = 0.1, color = "blue", linewidth = 0.5) +  # Individual scenarios
geom_line(data = df_mean, aes(x = Month, y = Value), color = "red",
linewidth = 1.2, inherit.aes = FALSE) +  # Mean expectation
scale_y_continuous(labels = label_number(scale_cut = cut_short_scale())) +  # Normal notation
theme_minimal() +
labs(title = "Stochastic Process of Simulations",
subtitle = subtitle_text,
x = "Month",
y = "Value") +
theme(legend.position = "none")
24*10
placa_couple = 5000
procent_invest = 0.4
roi_market = 0.09
sd = 0.04
leta = 30
N = 1000
razvoji= list()
for(i in 1:N){
cash = placa_couple*procent_invest
## razvoj
for(j in 2:(leta*12)){
cash[length(cash)] = cash[length(cash)]*(1 + rnorm(1,mean=roi_market/13,sd=sd)) ## market roi
cash = c(cash,cash[length(cash)]+placa_couple*procent_invest)
}
razvoji[[length(razvoji)+1]] = cash
}
razvoji = do.call(cbind,razvoji)
library(ggplot2)
library(reshape2)
library(scales)  # For normal notation on y-axis
df <- as.data.frame(razvoji)
df$Month <- 1:nrow(df)
# Reshape data to long format
df_long <- melt(df, id.vars = "Month", variable.name = "Scenario", value.name = "Value")
# Compute the mean expectation for each month
df_mean <- aggregate(Value ~ Month, data = df_long, FUN = mean)
# Subtitle text
subtitle_text <- paste(
"Params: Placa Couple =", placa_couple,
"| % Invest =", procent_invest,
"| ROI Market =", roi_market,
"| SD =", sd,
"| Years =", leta,
"| N =", N
)
# Plot with individual scenarios and mean line
ggplot(df_long, aes(x = Month, y = Value, group = Scenario)) +
geom_line(alpha = 0.1, color = "blue", linewidth = 0.5) +  # Individual scenarios
geom_line(data = df_mean, aes(x = Month, y = Value), color = "red",
linewidth = 1.2, inherit.aes = FALSE) +  # Mean expectation
scale_y_continuous(labels = label_number(scale_cut = cut_short_scale())) +  # Normal notation
theme_minimal() +
labs(title = "Stochastic Process of Simulations",
subtitle = subtitle_text,
x = "Month",
y = "Value") +
theme(legend.position = "none")
setwd("~/Desktop/backtest")
dir.create(("arch"))
setwd("~/Desktop/backtest/arch")
dir.create("data")
dir.create("code")
source("code/lib.R")
source("~/Desktop/backtest/arch/code/prepare_data.R", echo=TRUE)
data <- readRDS("~/Desktop/backtest/00_BIG_RULE/data/spx_min.RDS")
data <- readRDS("~/Desktop/backtest/00_BIG_RULE/data/spx_min.RDS")
head(data)
tail(data)
# ensure datetime is POSIXct (adjust tz if you need a specific timezone)
data <- data %>%
mutate(datetime = as.POSIXct(datetime, tz = "UTC"))
# floor to 15-min period and aggregate
oh15 <- data %>%
mutate(period = floor_date(datetime, "15 minutes")) %>%
group_by(period) %>%
summarise(
open  = open[which.min(datetime)],   # open at earliest minute in the period
high  = max(high, na.rm = TRUE),
low   = min(low,  na.rm = TRUE),
close = close[which.max(datetime)],  # close at latest minute in the period
.groups = "drop"
) %>%
arrange(period)
library(lubridate)
# ensure datetime is POSIXct (adjust tz if you need a specific timezone)
data <- data %>%
mutate(datetime = as.POSIXct(datetime, tz = "UTC"))
# floor to 15-min period and aggregate
oh15 <- data %>%
mutate(period = floor_date(datetime, "15 minutes")) %>%
group_by(period) %>%
summarise(
open  = open[which.min(datetime)],   # open at earliest minute in the period
high  = max(high, na.rm = TRUE),
low   = min(low,  na.rm = TRUE),
close = close[which.max(datetime)],  # close at latest minute in the period
.groups = "drop"
) %>%
arrange(period)
for(i in 1:nrow(oh15)){
print(oh15[i,])
}
for(i in 1:nrow(oh15)){
print(oh15$period[i])
}
system.time({
for(i in 1:nrow(oh15)){
## do some strat
2+2
}
})
View(oh15)
data = oh15 %>% as.data.frame()
class(data)
data$SMA_20 = data$close/SMA(data$close,20)
data$SMA_50 = data$close/SMA(data$close,50)
data$EMA_8 = data$close/EMA(data$close,8)
View(data)
data = na.omit(data)
saveRDS(data,"data/prepared_ta.RDS")
source("code/lib.R")
source("code/lib.R")
data = readRDS("data/prepared_ta.RDS")
head(data)
tail(data)
strat <- data %>%
mutate(
# detect SMA_50 crossing from below 1 to above 1
sma50_cross_up = (lag(SMA_50) < 1 & SMA_50 >= 1),
# condition: SMA_20 > 1 and EMA_8 > 1
cond = (SMA_20 > 1 & EMA_8 > 1),
# final signal
signal = ifelse(sma50_cross_up & cond, 1, 0)
)
View(strat)
backtest <- function(df, stop_pct = 0.02) {
trades <- list()
i <- 1
while (i <= nrow(df)) {
if (df$signal[i] == 1) {
entry_time  <- df$period[i]
entry_price <- df$close[i]
max_close <- entry_price
exit_time <- NA
exit_price <- NA
# move forward through rows after entry
for (j in (i+1):nrow(df)) {
max_close <- max(max_close, df$close[j])
trail_stop <- max_close * (1 - stop_pct)
if (df$close[j] <= trail_stop) {
exit_time  <- df$period[j]
exit_price <- df$close[j]
i <- j      # continue from exit bar
break
}
}
# if never hit stop, exit at last available bar
if (is.na(exit_time)) {
exit_time  <- df$period[nrow(df)]
exit_price <- df$close[nrow(df)]
i <- nrow(df)
}
trades[[length(trades)+1]] <- data.frame(
entry_time, entry_price, exit_time, exit_price,
return = (exit_price / entry_price) - 1
)
}
i <- i + 1
}
trades <- do.call(rbind, trades)
return(trades)
}
# Run backtest
results <- backtest(strat, stop_pct = 0.02)
View(results)
backtest <- function(df, stop_pct = 0.02) {
trades <- list()
i <- 1
while (i <= nrow(df)) {
if (df$signal[i] == 1) {
entry_time  <- df$period[i]
entry_price <- df$close[i]
max_close <- entry_price
exit_time <- NA
exit_price <- NA
exit_trail_stop <- NA
# move forward after entry
for (j in (i+1):nrow(df)) {
max_close <- max(max_close, df$close[j])
trail_stop <- max_close * (1 - stop_pct)
if (df$close[j] <= trail_stop) {
exit_time  <- df$period[j]
exit_price <- df$close[j]
exit_trail_stop <- trail_stop
i <- j
break
}
}
# if never stopped out, close at last bar
if (is.na(exit_time)) {
exit_time  <- df$period[nrow(df)]
exit_price <- df$close[nrow(df)]
exit_trail_stop <- max_close * (1 - stop_pct)
i <- nrow(df)
}
trades[[length(trades)+1]] <- data.frame(
entry_time,
entry_price,
exit_time,
exit_price,
trailing_max   = max_close,
trailing_stop  = exit_trail_stop,
return = (exit_price / entry_price) - 1
)
}
i <- i + 1
}
trades <- do.call(rbind, trades)
return(trades)
}
# Run backtest
results <- backtest(strat, stop_pct = 0.02)
View(results)
# Run backtest
results <- backtest(strat, stop_pct = 0.02)
tail(results)
# prepare equity curve
equity <- results %>%
mutate(cum_return = cumsum(return)) %>%
mutate(trade_id = row_number())
# compute stats
winrate <- mean(results$return > 0)
sharpe <- mean(results$return) / sd(results$return) * sqrt(nrow(results))
sortino <- mean(results$return) / sd(pmin(results$return, 0)) * sqrt(nrow(results))
title_text <- sprintf(
"Cumulative Return | Sharpe: %.2f | Sortino: %.2f | Winrate: %.1f%%",
sharpe, sortino, winrate * 100
)
# plot
ggplot(equity, aes(x = trade_id, y = cum_return)) +
geom_line(color = "steelblue", size = 1) +
geom_point(color = "darkblue", size = 1.5) +
theme_minimal(base_size = 14) +
labs(
title = title_text,
x = "Trade #",
y = "Cumulative Return"
)
# Run backtest
results <- backtest(strat, stop_pct = 0.02)
tail(results)
# prepare equity curve with compounding
equity <- results %>%
arrange(entry_time) %>%
mutate(cum_equity = cumprod(1 + return) - 1)
# compute stats
winrate <- mean(results$return > 0)
sharpe <- mean(results$return) / sd(results$return) * sqrt(nrow(results))
sortino <- mean(results$return) / sd(pmin(results$return, 0)) * sqrt(nrow(results))
title_text <- sprintf(
"Cumulative Return | Sharpe: %.2f | Sortino: %.2f | Winrate: %.1f%%",
sharpe, sortino, winrate * 100
)
# plot
ggplot(equity, aes(x = entry_time, y = cum_equity)) +
geom_line(color = "steelblue", size = 1) +
geom_point(color = "darkblue", size = 1.5) +
theme_minimal(base_size = 14) +
labs(
title = title_text,
x = "Time",
y = "Cumulative Return"
)
source("~/Desktop/backtest/arch/code/strategy.R", echo=TRUE)
source("~/Desktop/backtest/arch/code/strategy.R", echo=TRUE)
source("~/Desktop/backtest/arch/code/strategy.R", echo=TRUE)
30000
2/30000
2/300000
source("code/lib.R")
data = readRDS("data/prepared_ta.RDS")
head(data)
tail(data)
## SMA EMA crossover
strat <- data %>%
mutate(
# detect SMA_50 crossing from below 1 to above 1
sma50_cross_up = (lag(SMA_50) < 1 & SMA_50 >= 1),
# condition: SMA_20 > 1 and EMA_8 > 1
cond = (SMA_20 > 1 & EMA_8 > 1),
# final signal
signal = ifelse(sma50_cross_up & cond, 1, 0)
)
## vtopsva v trejd ko je 1
## assumption vstopiva na close
## trail 3% sl
library(dplyr)
backtest <- function(df, stop_pct = 0.02, fee = 2/300000) {
trades <- list()
i <- 1
while (i <= nrow(df)) {
if (df$signal[i] == 1) {
entry_time  <- df$period[i]
raw_entry_price <- df$close[i]
# fee-adjusted entry
entry_price <- raw_entry_price * (1 + fee)
max_close <- raw_entry_price   # trailing logic uses raw closes
exit_time <- NA
raw_exit_price <- NA
exit_price <- NA
exit_trail_stop <- NA
# forward scan
for (j in (i+1):nrow(df)) {
max_close <- max(max_close, df$close[j])
trail_stop <- max_close * (1 - stop_pct)
if (df$close[j] <= trail_stop) {
exit_time  <- df$period[j]
raw_exit_price <- df$close[j]
exit_price <- raw_exit_price * (1 - fee)   # fee-adjusted exit
exit_trail_stop <- trail_stop
i <- j
break
}
}
# if no stop hit, exit at last bar
if (is.na(exit_time)) {
exit_time  <- df$period[nrow(df)]
raw_exit_price <- df$close[nrow(df)]
exit_price <- raw_exit_price * (1 - fee)
exit_trail_stop <- max_close * (1 - stop_pct)
i <- nrow(df)
}
trades[[length(trades)+1]] <- data.frame(
entry_time,
entry_price,        # fee-adjusted
exit_time,
exit_price,         # fee-adjusted
trailing_max   = max_close,
trailing_stop  = exit_trail_stop,
return = (exit_price / entry_price) - 1
)
}
i <- i + 1
}
trades <- do.call(rbind, trades)
return(trades)
}
# Run backtest
results <- backtest(strat, stop_pct = 0.02)
tail(results)
# prepare equity curve with compounding
equity <- results %>%
arrange(entry_time) %>%
mutate(cum_equity = cumprod(1 + return) - 1)
# compute stats
winrate <- mean(results$return > 0)
sharpe <- mean(results$return) / sd(results$return) * sqrt(nrow(results))
sortino <- mean(results$return) / sd(pmin(results$return, 0)) * sqrt(nrow(results))
title_text <- sprintf(
"Cumulative Return | Sharpe: %.2f | Sortino: %.2f | Winrate: %.1f%%",
sharpe, sortino, winrate * 100
)
# plot
ggplot(equity, aes(x = entry_time, y = cum_equity)) +
geom_line(color = "steelblue", size = 1) +
geom_point(color = "darkblue", size = 1.5) +
theme_minimal(base_size = 14) +
labs(
title = title_text,
x = "Time",
y = "Cumulative Return"
)
